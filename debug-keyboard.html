<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>キーボード操作デバッグ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .input-field {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        .log {
            background: #f8f8f8;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .status {
            padding: 5px 10px;
            border-radius: 3px;
            margin: 5px 0;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        .info { background: #d1ecf1; color: #0c5460; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MindFlow キーボード操作デバッグツール</h1>
        
        <div class="test-section">
            <h3>1. 基本的なキー検出テスト</h3>
            <p>この入力フィールドでTab/Enterキーを押してください：</p>
            <input type="text" class="input-field" id="basicInput" placeholder="Tab/Enterキーをテスト">
            <div class="log" id="basicLog"></div>
            <button onclick="clearLog('basicLog')">ログクリア</button>
        </div>

        <div class="test-section">
            <h3>2. React-like イベント処理テスト</h3>
            <p>MindFlowと同様の処理をシミュレート：</p>
            <input type="text" class="input-field" id="reactInput" placeholder="テキストを入力してTab/Enter">
            <div id="nodeList"></div>
            <div class="log" id="reactLog"></div>
            <button onclick="clearLog('reactLog')">ログクリア</button>
            <button onclick="resetNodes()">ノードリセット</button>
        </div>

        <div class="test-section">
            <h3>3. 状態管理テスト</h3>
            <div class="status info" id="stateDisplay">編集状態: 待機中</div>
            <input type="text" class="input-field" id="stateInput" placeholder="状態変化を監視">
            <div class="log" id="stateLog"></div>
            <button onclick="clearLog('stateLog')">ログクリア</button>
        </div>

        <div class="test-section">
            <h3>4. タイミング競合テスト</h3>
            <p>連続的なキー入力での競合をテスト：</p>
            <input type="text" class="input-field" id="timingInput" placeholder="素早くTab/Enterを連打">
            <div class="log" id="timingLog"></div>
            <button onclick="clearLog('timingLog')">ログクリア</button>
        </div>
    </div>

    <script>
        // ログ表示関数
        function addLog(logId, message, type = 'info') {
            const log = document.getElementById(logId);
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = type;
            entry.textContent = `[${time}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function clearLog(logId) {
            document.getElementById(logId).innerHTML = '';
        }

        // 1. 基本的なキー検出テスト
        document.getElementById('basicInput').addEventListener('keydown', function(e) {
            addLog('basicLog', `KeyDown: ${e.key} (code: ${e.code}, keyCode: ${e.keyCode})`, 'info');
            
            if (e.key === 'Tab') {
                e.preventDefault();
                addLog('basicLog', 'Tab処理: preventDefault()実行', 'success');
            } else if (e.key === 'Enter') {
                e.preventDefault();
                addLog('basicLog', 'Enter処理: preventDefault()実行', 'success');
            }
        });

        // 2. React-like イベント処理テスト
        let nodes = [];
        let currentEditingId = null;
        let editText = '';

        function updateNodeList() {
            const list = document.getElementById('nodeList');
            list.innerHTML = nodes.map((node, i) => 
                `<div style="margin: 5px 0; padding: 5px; border: 1px solid #ccc; background: ${node.id === currentEditingId ? '#ffffcc' : 'white'}">
                    ノード${i + 1}: "${node.text}" ${node.id === currentEditingId ? '(編集中)' : ''}
                </div>`
            ).join('');
        }

        function createNode(text = '') {
            const id = 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const node = { id, text };
            nodes.push(node);
            addLog('reactLog', `ノード作成: ${id} テキスト:"${text}"`, 'success');
            return node;
        }

        function finishEdit(nodeId, newText) {
            addLog('reactLog', `finishEdit呼び出し: nodeId=${nodeId}, newText="${newText}", editText="${editText}"`, 'info');
            
            const textToSave = newText !== undefined ? newText : editText;
            
            if (!textToSave || textToSave.trim() === '') {
                addLog('reactLog', '空のテキスト検出 - ノードを削除', 'warning');
                nodes = nodes.filter(n => n.id !== nodeId);
                currentEditingId = null;
                editText = '';
                updateNodeList();
                return;
            }
            
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                node.text = textToSave.trim();
                addLog('reactLog', `テキスト保存: "${textToSave.trim()}"`, 'success');
            }
            
            currentEditingId = null;
            editText = '';
            updateNodeList();
        }

        function addSiblingNode(nodeId) {
            addLog('reactLog', `兄弟ノード追加要求: ${nodeId}`, 'info');
            const newNode = createNode('');
            currentEditingId = newNode.id;
            editText = '';
            
            // フォーカスをリセット
            setTimeout(() => {
                document.getElementById('reactInput').focus();
                addLog('reactLog', `新しいノード編集開始: ${newNode.id}`, 'success');
                updateNodeList();
            }, 50);
        }

        document.getElementById('reactInput').addEventListener('input', function(e) {
            editText = e.target.value;
            addLog('reactLog', `editText更新: "${editText}"`, 'info');
        });

        document.getElementById('reactInput').addEventListener('keydown', function(e) {
            addLog('reactLog', `KeyDown in React-like: ${e.key}, editText="${editText}"`, 'info');
            
            if (e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation();
                
                const currentText = editText.trim();
                addLog('reactLog', `Enter処理開始: currentText="${currentText}"`, 'info');
                
                if (currentEditingId) {
                    finishEdit(currentEditingId, currentText);
                }
                
                if (currentText) {
                    setTimeout(() => {
                        addSiblingNode(currentEditingId || 'dummy');
                    }, 100);
                } else {
                    addLog('reactLog', '空のテキストのため新規ノード作成スキップ', 'warning');
                }
                
                this.value = '';
                editText = '';
            }
        });

        function resetNodes() {
            nodes = [];
            currentEditingId = null;
            editText = '';
            updateNodeList();
            document.getElementById('reactInput').value = '';
            addLog('reactLog', 'ノードリセット完了', 'info');
        }

        // 初期ノード作成
        createNode('ルートノード');
        updateNodeList();

        // 3. 状態管理テスト
        let editingState = 'idle';
        let stateEditText = '';

        function updateStateDisplay() {
            document.getElementById('stateDisplay').textContent = 
                `編集状態: ${editingState}, テキスト: "${stateEditText}"`;
        }

        document.getElementById('stateInput').addEventListener('focus', function() {
            editingState = 'editing';
            updateStateDisplay();
            addLog('stateLog', '編集開始', 'success');
        });

        document.getElementById('stateInput').addEventListener('blur', function() {
            editingState = 'idle';
            updateStateDisplay();
            addLog('stateLog', '編集終了 (blur)', 'warning');
        });

        document.getElementById('stateInput').addEventListener('input', function(e) {
            stateEditText = e.target.value;
            updateStateDisplay();
            addLog('stateLog', `テキスト変更: "${stateEditText}"`, 'info');
        });

        document.getElementById('stateInput').addEventListener('keydown', function(e) {
            addLog('stateLog', `KeyDown (状態: ${editingState}): ${e.key}`, 'info');
        });

        // 4. タイミング競合テスト
        let timingCounter = 0;
        let lastKeyTime = 0;

        document.getElementById('timingInput').addEventListener('keydown', function(e) {
            const now = Date.now();
            const timeDiff = now - lastKeyTime;
            lastKeyTime = now;
            
            if (e.key === 'Tab' || e.key === 'Enter') {
                e.preventDefault();
                timingCounter++;
                addLog('timingLog', `${e.key} #${timingCounter} (間隔: ${timeDiff}ms)`, 
                      timeDiff < 100 ? 'error' : 'success');
                
                if (timeDiff < 100) {
                    addLog('timingLog', '⚠️ 高速入力検出 - 競合の可能性', 'error');
                }
            }
        });

        // 初期表示更新
        updateStateDisplay();
    </script>
</body>
</html>