import { useState, useCallback, useEffect } from 'react';
import { useMindMapData } from '../../features/mindmap/useMindMapData.js';
import { useMindMapNodes } from '../../features/mindmap/useMindMapNodes.js';
import { useMindMapFiles } from '../../features/files/useMindMapFiles.js';
import { useMindMapMulti } from '../../features/mindmap/useMindMapMulti.js';
import type { MindMapData, MindMapNode, User } from '../../shared/types/index.js';

type NavigationDirection = 'up' | 'down' | 'left' | 'right';

interface UseMindMapResult {
  // „Éá„Éº„Çø
  data: MindMapData | null;
  selectedNodeId: string | null;
  editingNodeId: string | null;
  editText: string;
  
  // Áä∂ÊÖãÊõ¥Êñ∞
  setSelectedNodeId: (id: string | null) => void;
  setEditingNodeId: (id: string | null) => void;
  setEditText: (text: string) => void;
  
  // „Éé„Éº„ÉâÊìç‰Ωú
  updateNode: (nodeId: string, updates: Partial<MindMapNode>) => void;
  addChildNode: (parentId: string, text?: string, startEditing?: boolean) => Promise<void>;
  addSiblingNode: (siblingId: string, text?: string, startEditing?: boolean) => Promise<void>;
  deleteNode: (nodeId: string) => void;
  dragNode: (nodeId: string, x: number, y: number) => void;
  changeParent: (nodeId: string, newParentId: string) => void;
  findNode: (nodeId: string) => MindMapNode | null;
  findParentNode: (nodeId: string) => MindMapNode | null;
  flattenNodes: (rootNode: MindMapNode) => MindMapNode[];
  applyAutoLayout: (algorithm?: string) => void;
  navigateToDirection: (direction: NavigationDirection) => void;
  
  // Á∑®ÈõÜ
  startEdit: (nodeId: string) => void;
  finishEdit: (nodeId: string, text: string) => void;
  
  // Êäò„Çä„Åü„Åü„Åø
  toggleCollapse: (nodeId: string) => void;
  
  // „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥
  zoom: number;
  setZoom: (zoom: number) => void;
  pan: { x: number; y: number };
  setPan: (pan: { x: number; y: number }) => void;
  resetView: () => void;
  
  // „Éï„Ç°„Ç§„É´Ê∑ª‰ªò
  attachFileToNode: (nodeId: string, file: File) => Promise<void>;
  removeFileFromNode: (nodeId: string, fileId: string) => void;
  renameFileInNode: (nodeId: string, fileId: string, newName: string) => void;
  downloadFile: (file: File) => void;
  isAppInitializing: boolean;
  
  // Â±•Ê≠¥
  undo: () => void;
  redo: () => void;
  canUndo: boolean;
  canRedo: boolean;
  
  // „Åù„ÅÆ‰ªñ
  updateTitle: (title: string) => void;
  changeTheme: (theme: string) => void;
  updateSettings: (settings: any) => void;
  saveMindMap: () => Promise<void>;
  triggerCloudSync: () => void;
  
  // „Éû„É´„ÉÅ„Éû„ÉÉ„ÉóÁÆ°ÁêÜ
  allMindMaps: any[];
  currentMapId: string | null;
  createMindMap: (title?: string) => Promise<void>;
  renameMindMap: (mapId: string, newTitle: string) => Promise<void>;
  deleteMindMapById: (mapId: string) => Promise<void>;
  switchToMap: (mapId: string, selectRoot?: boolean) => Promise<void>;
  refreshAllMindMaps: () => Promise<void>;
  
  // „Ç´„ÉÜ„Ç¥„É™„ÉºÁÆ°ÁêÜ
  changeMapCategory: (mapId: string, category: string) => Promise<void>;
  getAvailableCategories: () => string[];
  
  // ÂàùÊúüÂåñÁÆ°ÁêÜ
  reinitializeAfterModeSelection: () => Promise<void>;
}

// Á∑äÊÄ•Âæ©Êóß: ÂÆåÂÖ®„Å´Á∞°Áï•Âåñ„Åï„Çå„ÅüuseMindMapÔºàÂ∏∏„Å´Âêå„Åò„Éï„ÉÉ„ÇØÊï∞Ôºâ
export const useMindMap = (isAppReady: boolean = false): UseMindMapResult => {
  // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞„ÇíÂà∂ÈôêÔºàÂàùÂõû„ÅÆ„ÅøÔºâ
  const [debugLogged, setDebugLogged] = useState(false);
  
  // üö® ÈáçË¶Å: isAppReady„Å´Èñ¢‰øÇ„Å™„Åè„ÄÅÂ∏∏„Å´Âêå„ÅòÈ†ÜÂ∫è„Åß„Éï„ÉÉ„ÇØ„ÇíÂëº„Å≥Âá∫„Åô
  const dataHook = useMindMapData(isAppReady);
  
  // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞ÔºàÂàùÂõû„Åæ„Åü„ÅØÁä∂ÊÖãÂ§âÂåñÊôÇ„ÅÆ„ÅøÔºâ
  useEffect(() => {
    if (!debugLogged || (dataHook.data?.id && !debugLogged)) {
      console.log('üîß useMindMap called with isAppReady:', isAppReady);
      console.log('üìä Data hook result:', { hasData: !!dataHook.data, title: dataHook.data?.title });
      setDebugLogged(true);
    }
  }, [isAppReady, dataHook.data?.id, debugLogged]);
  
  // „Éé„Éº„ÉâÊìç‰ΩúÔºàdata„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøÔºâ
  const nodeHook = useMindMapNodes(dataHook.data, dataHook.updateData, dataHook.blockRealtimeSyncTemporarily);
  
  // „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥ÔºàÁ∞°Áï•ÂåñÁâàÔºâ
  const [zoom, setZoom] = useState(1);
  const [pan, setPan] = useState({ x: 0, y: 0 });
  
  const navigateToDirection = useCallback((direction: NavigationDirection): void => {
    console.log('üß≠ Navigate to direction:', direction, { selectedNodeId: nodeHook.selectedNodeId });
    
    if (!nodeHook.selectedNodeId || !dataHook.data?.rootNode) {
      console.log('‚ö†Ô∏è Navigation cancelled: no selected node or data');
      return;
    }
    
    const allNodes = nodeHook.flattenNodes(dataHook.data.rootNode);
    const currentNode = nodeHook.findNode(nodeHook.selectedNodeId);
    if (!currentNode) {
      console.log('‚ö†Ô∏è Navigation cancelled: current node not found');
      return;
    }
    
    let targetNode: MindMapNode | null = null;
    let minDistance = Infinity;
    
    // Â∫ßÊ®ô„Éô„Éº„Çπ„ÅßÊñπÂêë„Å´„ÅÇ„Çã„Éé„Éº„Éâ„ÇíÊé¢„Åô
    allNodes.forEach(node => {
      if (node.id === nodeHook.selectedNodeId) return;
      
      const dx = node.x - currentNode.x;
      const dy = node.y - currentNode.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      let isInDirection = false;
      
      switch (direction) {
        case 'up':
          isInDirection = dy < -20 && Math.abs(dx) < Math.abs(dy);
          break;
        case 'down':
          isInDirection = dy > 20 && Math.abs(dx) < Math.abs(dy);
          break;
        case 'left':
          isInDirection = dx < -20 && Math.abs(dy) < Math.abs(dx);
          break;
        case 'right':
          isInDirection = dx > 20 && Math.abs(dy) < Math.abs(dx);
          break;
      }
      
      if (isInDirection && distance < minDistance) {
        minDistance = distance;
        targetNode = node;
      }
    });
    
    // ÊñπÂêë„Å´„Éé„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÈöéÂ±§Èñ¢‰øÇ„Åß‰ª£Êõø
    if (!targetNode) {
      console.log('üîÑ No node found in direction, trying hierarchical fallback');
      
      switch (direction) {
        case 'up':
          // ‰∏äÊñπÂêë: Ë¶™„Éé„Éº„Éâ„ÇíÈÅ∏Êäû
          targetNode = nodeHook.findParentNode(nodeHook.selectedNodeId);
          break;
        case 'down':
          // ‰∏ãÊñπÂêë: ÊúÄÂàù„ÅÆÂ≠ê„Éé„Éº„Éâ„ÇíÈÅ∏Êäû
          targetNode = currentNode.children && currentNode.children.length > 0 
            ? currentNode.children[0] : null;
          break;
        case 'left':
          // Â∑¶ÊñπÂêë: Ââç„ÅÆÂÖÑÂºü„Éé„Éº„Éâ„ÇíÈÅ∏Êäû
          const leftParent = nodeHook.findParentNode(nodeHook.selectedNodeId);
          if (leftParent && leftParent.children) {
            const currentIndex = leftParent.children.findIndex(child => child.id === nodeHook.selectedNodeId);
            targetNode = currentIndex > 0 ? leftParent.children[currentIndex - 1] : null;
          }
          break;
        case 'right':
          // Âè≥ÊñπÂêë: Ê¨°„ÅÆÂÖÑÂºü„Éé„Éº„Éâ„ÇíÈÅ∏Êäû
          const rightParent = nodeHook.findParentNode(nodeHook.selectedNodeId);
          if (rightParent && rightParent.children) {
            const currentIndex = rightParent.children.findIndex(child => child.id === nodeHook.selectedNodeId);
            targetNode = currentIndex < rightParent.children.length - 1 
              ? rightParent.children[currentIndex + 1] : null;
          }
          break;
      }
    }
    
    if (targetNode) {
      console.log('‚úÖ Navigation successful:', { from: nodeHook.selectedNodeId, to: targetNode.id, direction });
      nodeHook.setSelectedNodeId(targetNode.id);
    } else {
      console.log('‚ö†Ô∏è No target node found for direction:', direction);
    }
  }, [nodeHook.selectedNodeId, dataHook.data, nodeHook.flattenNodes, nodeHook.findNode, nodeHook.findParentNode, nodeHook.setSelectedNodeId]);

  // „Éû„É´„ÉÅ„Éû„ÉÉ„ÉóÁÆ°ÁêÜ
  const multiHook = useMindMapMulti(dataHook.data, dataHook.setData, dataHook.updateData);
  
  // „Éï„Ç°„Ç§„É´Ê∑ª‰ªò
  const fileHook = useMindMapFiles(nodeHook.findNode, nodeHook.updateNode, multiHook.currentMapId);

  return {
    // „Éá„Éº„Çø
    data: dataHook.data,
    selectedNodeId: nodeHook.selectedNodeId,
    editingNodeId: nodeHook.editingNodeId,
    editText: nodeHook.editText,
    
    // Áä∂ÊÖãÊõ¥Êñ∞
    setSelectedNodeId: nodeHook.setSelectedNodeId,
    setEditingNodeId: nodeHook.setEditingNodeId,
    setEditText: nodeHook.setEditText,
    
    // „Éé„Éº„ÉâÊìç‰Ωú
    updateNode: nodeHook.updateNode,
    addChildNode: nodeHook.addChildNode,
    addSiblingNode: nodeHook.addSiblingNode,
    deleteNode: nodeHook.deleteNode,
    dragNode: nodeHook.dragNode,
    changeParent: nodeHook.changeParent,
    findNode: nodeHook.findNode,
    findParentNode: nodeHook.findParentNode,
    flattenNodes: nodeHook.flattenNodes,
    applyAutoLayout: nodeHook.applyAutoLayout,
    navigateToDirection,
    
    // Á∑®ÈõÜ
    startEdit: nodeHook.startEdit,
    finishEdit: nodeHook.finishEdit,
    
    // Êäò„Çä„Åü„Åü„Åø
    toggleCollapse: nodeHook.toggleCollapse,
    
    // „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥ (Á∞°Áï•Âåñ)
    zoom,
    setZoom,
    pan,
    setPan,
    resetView: () => {
      setZoom(1);
      setPan({ x: 0, y: 0 });
    },
    
    // „Éï„Ç°„Ç§„É´Ê∑ª‰ªò
    attachFileToNode: fileHook.attachFileToNode,
    removeFileFromNode: fileHook.removeFileFromNode,
    renameFileInNode: fileHook.renameFileInNode,
    downloadFile: fileHook.downloadFile,
    isAppInitializing: fileHook.isAppInitializing,
    
    // Â±•Ê≠¥
    undo: dataHook.undo,
    redo: dataHook.redo,
    canUndo: dataHook.canUndo,
    canRedo: dataHook.canRedo,
    
    // „Åù„ÅÆ‰ªñ
    updateTitle: dataHook.updateTitle,
    changeTheme: dataHook.changeTheme,
    updateSettings: dataHook.updateSettings,
    saveMindMap: dataHook.saveMindMap,
    triggerCloudSync: dataHook.triggerCloudSync,
    
    // „Éû„É´„ÉÅ„Éû„ÉÉ„ÉóÁÆ°ÁêÜ
    allMindMaps: multiHook.allMindMaps,
    currentMapId: multiHook.currentMapId,
    createMindMap: multiHook.createMindMap,
    renameMindMap: multiHook.renameMindMap,
    deleteMindMapById: multiHook.deleteMindMapById,
    switchToMap: (mapId, selectRoot = false) => {
      return multiHook.switchToMap(
        mapId, 
        selectRoot, 
        nodeHook.setSelectedNodeId, 
        nodeHook.setEditingNodeId, 
        nodeHook.setEditText, 
        dataHook.setHistory, 
        dataHook.setHistoryIndex,
        nodeHook.finishEdit  // finishEdit„ÇíÊ∏°„Åô
      );
    },
    refreshAllMindMaps: multiHook.refreshAllMindMaps,
    
    // „Ç´„ÉÜ„Ç¥„É™„ÉºÁÆ°ÁêÜ
    changeMapCategory: multiHook.changeMapCategory,
    getAvailableCategories: multiHook.getAvailableCategories,
    
    // ÂàùÊúüÂåñÁÆ°ÁêÜ
    reinitializeAfterModeSelection: multiHook.reinitializeAfterModeSelection
  };
};